(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{718:function(t,e,a){"use strict";a.r(e);var n=a(1),o=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),a("p",[t._v("Vite is a high-performance decentralized application platform built on asynchronous message-driven architecture.\nThe smart contracts in Vite are written in Solidity++, a programming language that extends Solidity by adding asynchronous semantics while maintains major compatibility.\nSmart contracts in Vite won't share states but communicate with each other via sending messages.")]),t._v(" "),a("h2",{attrs:{id:"what-is-asynchronous-smart-contract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-asynchronous-smart-contract"}},[t._v("#")]),t._v(" What is Asynchronous Smart Contract")]),t._v(" "),a("p",[t._v("Inter-contract calls in Ethereum are represented as sychronous function calls. This set of calls are either completed at the same time or all fail. Obviously, this kind of atomic semantics could become a performance bottleneck in system.")]),t._v(" "),a("p",[t._v("To tackle the issue, Vite adopts an asynchronous, message-driven architecture. Smart contracts in Vite communicate with each other via sending messages instead of sharing their states.")]),t._v(" "),a("p",[t._v("Similar to token transfer, a contract call is separated into a "),a("em",[t._v("contract request transaction")]),t._v(" and a "),a("em",[t._v("contract response transaction")]),t._v(", representing as transaction blocks appended into the account chains of requester and responder of a contract call respectively.")]),t._v(" "),a("p",[t._v("The manner how these transactions are written to the ledger and how they are confirmed are also asynchronous. A "),a("em",[a("strong",[t._v("snapshotted")])]),t._v(" contract request transaction means the contract call is successfully initiated. A "),a("em",[a("strong",[t._v("snapshotted")])]),t._v(" contract response transaction indicates the contract call is completed.")]),t._v(" "),a("p",[t._v("There is no return value in asynchronous contract. Execution result should be returned to the caller by callback, which actually yields a new transaction after current execution process has completed.")]),t._v(" "),a("h2",{attrs:{id:"who-is-responsible-for-executing-smart-contract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#who-is-responsible-for-executing-smart-contract"}},[t._v("#")]),t._v(" Who is Responsible for Executing Smart Contract")]),t._v(" "),a("p",[t._v("When smart contract is created, the owner should designate a delegated consensus group. The delegated nodes in the group will execute the smart contract and generate transaction block using DPoS algorithm.")]),t._v(" "),a("p",[t._v("A smart contract can only designate one delegated consensus group, which can't be changed afterwards. A delegated consensus group can serve multiple smart contracts.")]),t._v(" "),a("p",[t._v("A built-in delegated consensus group, aka Global Consensus Group, is provided to serve smart contracts that haven't designated delegated consensus group. The block producers of Global Consensus Group are same with those of Snapshot Consensus Group but having different block producing order.")]),t._v(" "),a("h2",{attrs:{id:"priority-of-contract-response-transaction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#priority-of-contract-response-transaction"}},[t._v("#")]),t._v(" Priority of Contract Response Transaction")]),t._v(" "),a("p",[t._v("If multiple contracts have designated the same delegated consensus group, they could be prioritized according to how much quota they have. The higher quota the contract possesses, with the higher priority the transaction of the contract could be handled by consensus group.\nSince prioritization of contract response transactions is not specified in Vite's protocol, each delegated consensus group can define prioritization rules on its own.")]),t._v(" "),a("p",[t._v("FIFO(First In First Out) rule must be guaranteed when multiple messages are sent to a contract from the same account. In other words, the request transaction having lower block height is always accepted by the contract in ahead of that having higher height. FIFO does not apply to scenario where messages are sent out from different accounts.")]),t._v(" "),a("p",[t._v("If multiple accounts happen to send messages to a contract simultaneously, the delegated consensus group will choose a random processing order. However, the consensus group can define an algorithm for prioritization purpose on its own.")]),t._v(" "),a("h2",{attrs:{id:"cost-of-contract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cost-of-contract"}},[t._v("#")]),t._v(" Cost of Contract")]),t._v(" "),a("h3",{attrs:{id:"fees-for-creating-contract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fees-for-creating-contract"}},[t._v("#")]),t._v(" Fees for Creating Contract")]),t._v(" "),a("p",[t._v("Creating new contract consumes VITE. In Pre-Mainnet, a destruction of 10 VITE is required for creating a contract.")]),t._v(" "),a("h3",{attrs:{id:"quota-in-contract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quota-in-contract"}},[t._v("#")]),t._v(" Quota in Contract")]),t._v(" "),a("p",[t._v("The quota for contract creation request transaction is supplied by contract creator, while the quota consumed in contract creation response transaction comes from the destruction of VITE. In Pre-Mainnet, destroying 10 VITE during smart contract creation will receive quota up to 47.62 "),a("code",[t._v("UTPS")]),t._v(".")]),t._v(" "),a("p",[t._v("Similar to contract creation, contract execution consumes quota as well. The contract request transaction and the contract response transaction consume the quota of transaction initiator and contract account respectively.")]),t._v(" "),a("p",[t._v("In Pre-Mainnet, contract account can only obtain quota by staking. If a contract does not have sufficient quota, no transaction of this contract will be performed. Therefore, "),a("strong",[t._v("contract provider should always ensure 'enough' VITE tokens have been staked for the contract")]),t._v(".")]),t._v(" "),a("p",[t._v('For complex contract, the quota of contract account may be insufficient for generating response transaction. In this case, the response transaction will consume up the quota and fail in the end by generating a "failed" response block on the contract chain. And, if the request has carried transfer amount, the tokens will be returned to original account after transaction fails. In Pre-Mainnet, a "failed" contract response due to insufficient quota will cause the contract locked for 75 snapshot blocks. In other words, no transaction for the contract will be processed during the time until it is unlocked.')]),t._v(" "),a("h2",{attrs:{id:"smart-contract-language"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#smart-contract-language"}},[t._v("#")]),t._v(" Smart Contract Language")]),t._v(" "),a("p",[t._v("Ethereum provides Solidity, a Turing-complete programming language for developing smart contracts. To support asynchronous semantics, Vite extends Solidity and defines a set of syntax for message communication. The extended Solidity in Vite is called Solidity++.")]),t._v(" "),a("h2",{attrs:{id:"how-to-call-a-contract-asynchronously"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-call-a-contract-asynchronously"}},[t._v("#")]),t._v(" How to Call a Contract Asynchronously")]),t._v(" "),a("h3",{attrs:{id:"callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#callback"}},[t._v("#")]),t._v(" Callback")]),t._v(" "),a("p",[t._v("In previous versions of Solidity++, such as Solidity++ 0.4.3, developers can define "),a("em",[t._v("messages")]),t._v(" through "),a("code",[t._v("message")]),t._v(" keyword and define "),a("em",[t._v("callbacks")]),t._v(" via "),a("code",[t._v("onMessage")]),t._v(" keyword to enable cross-contract communication.")]),t._v(" "),a("p",[t._v("In a "),a("code",[t._v("onMessage")]),t._v(" declaration, one contract can call another contract by using "),a("code",[t._v("send")]),t._v(" statement. A "),a("code",[t._v("send")]),t._v(" statement in Solidity++ are compiled into a "),a("code",[t._v("CALL")]),t._v(" instruction.")]),t._v(" "),a("p",[t._v("As a result, a request transaction is generated and appended to Vite's DAG ledger, which plays a key role as message middleware for asynchronous communication between contracts, ensuring reliable storage of messages and preventing duplication.")]),t._v(" "),a("h3",{attrs:{id:"async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[t._v("#")]),t._v(" Async/Await")]),t._v(" "),a("p",[t._v("Since Solidity++ 0.8.0, we introduce a modern approach to asynchronous functions using async/await syntactic sugar.")]),t._v(" "),a("p",[t._v("To those familiar with mordern programming languages, the async/await provides a more elegant and readable way to organise asynchronous function calls, and implement more reliable and concise control flows.")]),t._v(" "),a("h2",{attrs:{id:"virtual-machine"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-machine"}},[t._v("#")]),t._v(" Virtual Machine")]),t._v(" "),a("p",[t._v("At present, Ethereum has a large community of developers, who have contributed abundant smart contracts based on Solidity and EVM environment.\nSince Vite's VM is partially compatible with EVM, most EVM instructions can maintain the original semantics in Vite. However, due to different ledger structure and transaction definition, the semantics of some EVM instructions need to be redefined.")]),t._v(" "),a("h3",{attrs:{id:"instruction-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instruction-set"}},[t._v("#")]),t._v(" Instruction Set")]),t._v(" "),a("p",[t._v("See "),a("RouterLink",{attrs:{to:"/contract/instructions.html"}},[t._v("Vite Instruction Set")])],1),t._v(" "),a("h2",{attrs:{id:"contract-debugging"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contract-debugging"}},[t._v("#")]),t._v(" Contract Debugging")]),t._v(" "),a("p",[t._v("See "),a("RouterLink",{attrs:{to:"/contract/debug.html"}},[t._v("Debugging Smart Contracts")])],1)])}),[],!1,null,null,null);e.default=o.exports}}]);